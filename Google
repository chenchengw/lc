1. give a string, all 1 or 0, we can flip a 0 to 1, find the longest 1 substring after the flipping

这是一个简单版本of LC 424 Longest Repeating Character Replacement

又是Window, 又是Two Pointers

Window还是采用每次都try to update left使得window valid, 每次都检查最大window

public class LongestOneSubstr {
    
    public static int find2(String str) {
        if (str==null || str.length()==0) return 0;
        int l = 0, r = 0;
        int maxLen = 0;
        int countZero = 0;
        for (r=0; r<str.length(); r++) {
            if (str.charAt(r) == '0') countZero++;
            while (countZero > 1 && l < str.length()) {
                if (str.charAt(l) == '0') countZero--;
                l++;
            }
            maxLen = Math.max(r-l+1, maxLen);
        }
        return maxLen;
    }

    /**
     * @param args
     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        System.out.println(find2("10111000010110111101101010101"));
    }

}


2. Implement a simple stock price display systemwhich will show High, Low and Last price for a given stock throughout one day.The data comes from a real-time feed and have the following messages:
PriceUpdate(t, P) -> Price of Stock A at timet is P.
Correction(t, NewP) -> Price of Stock A attime t is rectified to NewP
Remove(t) -> Disregard the price feedreceived at time t.
PriceUpdate(10100,850.50) -> high = 850.50, Low = 850.50, Last = 850.50
PriceUpdate(10200,852.25) -> high = 852.25, Low = 850.50, Last = 852.25
PriceUpdate(10300,848.00) -> high = 852.25, Low = 848.00, Last = 848.00
Correction(10200, 849.00) -> high = 850.50, Low = 848.00, Last 848.00
PriceUpdate(10400,855.00)  -> high = 855.00, Low = 848.00, Last = 855.00
Correction(10300, 853.00) -> high = 855.00, Low = 850.50, Last = 855.00
PriceUpdate(10500,854.00) -> high = 855.00, Low = 848.00, Last = 854.00
Correction(10500,853.25) -> high = 855.00, Low = 848.00, Last = 853.25
Remove(10300) -> high = 855.00, Low = 849.00, Last = 853.25

简单说来PriceUpdate就是添加新的（timestamp, price）, Correction是改之前的(timestamp, price), 求实现当前high(), low(), last()
感觉需要2个数据结构：
1. TreeMap<Long, Double> time2priceMap. 
2. TreeMap<Double, Integer> price2countMap

priceupdate: insert new record into time2priceMap, update price count in price2countmap
correction: update record in time2pricemap, update prev price count, update prev price count (if 0, remove record), update new price count or needs to insert a new price record into price2countmap
high and low: lastkey and firstkey from price2countmap
last: last entry's price from time2pricemap


3.
https://leetcode.com/problems/encode-string-with-shortest-length/description/

public class Solution {
    public String encode(String s) {
        if (s==null || s.length()==0) return "";
        String[][] dp = new String[s.length()][s.length()];
        
        for (int len=0; len<s.length(); len++) {
            for (int i=0; i+len<s.length(); i++) {
                int j = i + len;
                String subStr = s.substring(i, j+1);
                dp[i][j] = subStr; //initialize
                if (len < 4) continue;
                for (int k=i; k<j; k++) {
                    if (dp[i][k].length() + dp[k+1][j].length() < dp[i][j].length()) {
                        dp[i][j] = dp[i][k] + dp[k+1][j];
                    }
                }
                
                //check if subStr has repeat pattern
                for (int k=i; k<j; k++) {
                    String repeat = s.substring(i, k+1);
                    if (subStr.length()%(k-i+1)==0 && subStr.replaceAll(repeat, "").length()==0) {
                        String ss = subStr.length()/repeat.length() + "[" + dp[i][k] + "]";
                        if (ss.length() < dp[i][j].length()) 
                            dp[i][j] = ss;
                    }
                }
            }
        }
        return dp[0][s.length()-1];
    }
}
