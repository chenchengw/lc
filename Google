1. give a string, all 1 or 0, we can flip a 0 to 1, find the longest 1 substring after the flipping

这是一个简单版本of LC 424 Longest Repeating Character Replacement

又是Window, 又是Two Pointers

Window还是采用每次都try to update left使得window valid, 每次都检查最大window

public class LongestOneSubstr {
    
    public static int find2(String str) {
        if (str==null || str.length()==0) return 0;
        int l = 0, r = 0;
        int maxLen = 0;
        int countZero = 0;
        for (r=0; r<str.length(); r++) {
            if (str.charAt(r) == '0') countZero++;
            while (countZero > 1 && l < str.length()) {
                if (str.charAt(l) == '0') countZero--;
                l++;
            }
            maxLen = Math.max(r-l+1, maxLen);
        }
        return maxLen;
    }

    /**
     * @param args
     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        System.out.println(find2("10111000010110111101101010101"));
    }

}


2. Implement a simple stock price display systemwhich will show High, Low and Last price for a given stock throughout one day.The data comes from a real-time feed and have the following messages:
PriceUpdate(t, P) -> Price of Stock A at timet is P.
Correction(t, NewP) -> Price of Stock A attime t is rectified to NewP
Remove(t) -> Disregard the price feedreceived at time t.
PriceUpdate(10100,850.50) -> high = 850.50, Low = 850.50, Last = 850.50
PriceUpdate(10200,852.25) -> high = 852.25, Low = 850.50, Last = 852.25
PriceUpdate(10300,848.00) -> high = 852.25, Low = 848.00, Last = 848.00
Correction(10200, 849.00) -> high = 850.50, Low = 848.00, Last 848.00
PriceUpdate(10400,855.00)  -> high = 855.00, Low = 848.00, Last = 855.00
Correction(10300, 853.00) -> high = 855.00, Low = 850.50, Last = 855.00
PriceUpdate(10500,854.00) -> high = 855.00, Low = 848.00, Last = 854.00
Correction(10500,853.25) -> high = 855.00, Low = 848.00, Last = 853.25
Remove(10300) -> high = 855.00, Low = 849.00, Last = 853.25

简单说来PriceUpdate就是添加新的（timestamp, price）, Correction是改之前的(timestamp, price), 求实现当前high(), low(), last()
感觉需要2个数据结构：
1. TreeMap<Long, Double> time2priceMap. 
2. TreeMap<Double, Integer> price2countMap

priceupdate: insert new record into time2priceMap, update price count in price2countmap
correction: update record in time2pricemap, update prev price count, update prev price count (if 0, remove record), update new price count or needs to insert a new price record into price2countmap
high and low: lastkey and firstkey from price2countmap
last: last entry's price from time2pricemap


3.
