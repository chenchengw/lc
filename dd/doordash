最长连续序列。 (exactly one larger than the one that came before it) ex: 1, 2, 5, 6 -> 1, 2 ex: 3, 5, 6, 7, 12 -> 5, 6, 7 
https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/
follow up 变形：(exactly one larger than some number that came before it) ex: 1, 6, 2, 7, 3 -> 1, 2, 3 ex: 3, 5, 6, 7, 12 -> 5, 6, 7 
https://leetcode.com/problems/longest-increasing-subsequence/description/

sqrt() 变形 返回int， 但是跟leetcode 不同的是要返回平方后大于等于输入值的结果 比如输入15的话要返回4, 而不是3
https://leetcode.com/problems/sqrtx/description/



**/ 2. 第二轮 1. 类似于find target in rotated array不过是找的rotated的index在哪儿 
2. unique path I && II 

第一题找map中连续相同数字最多是多少，我用boolean【】【】判断是否visited，follow up就是看如何缩小这个space，
/** * @param matrix, a 2-d array (list of lists) of integers  
the size of the largest contiguous block (horizontally/vertically connected) of numbers with the same value 
int expected1 = 2; int matrix1 = new int {{1,2,3}, {4,1,6}, {4,5,1}}; 
int expected2 = 4;  int matrix2 = new int {{1,1,1,2,4}, {5,1,5,3,1}, {3,4,2,1,1}}; 
int expected3 = 11;  int matrix3 = new int {{3,3,3,3,3,1}, {3,4,4,4,3,4}, {2,4,3,3,3,4}, {2,4,4,4,4,4}}; 
int expected4 = 24; int matrix4 = new int{ {0,0,0,0,0}, {0,0,0,0,0}, {0,0,1,0,0}, {0,0,0,0,0}, {0,0,0,0,0}}; 

#dfs
123
416
451

11124
51531
34211

第二题是unique path，
follow up也是缩小space complexity

给一个BST的root，和两个node，求两个node的path 
第一轮lc原题： spiral matrix i & ii 
第二轮题大概是这样： // You’re given two sets of intervals, one for DoorDash and one for a restaurant, 
and you want to find when they are both open. These are hours in 24-hour times, but can be any arbitrary 
floating point numbers. // example: // D = // R = // =>

implement sqrt ＋ 一些些小的变化。

一轮电面很简单，就是permutation，不过不是数字 是character， abc这样的，输出abc， acb，bac，bca，cab，cba。
还有一个也是原题，add binary。
前天第一轮video，两轮两小时，美国小哥和美国小姐姐，题目也很简单，小姐姐的是spiral matrix，小哥的是找interval 的公共区间，和下面这个帖子说的一样。

第一轮： 系统设计， 设计airbnb database. 就是设计schema， tables，有哪些column，，，感觉面试官有点严厉。。。（原来以为会让设计 doordash api）
第二轮: white board coding, 类似leetcode 的word break， 不同之处是返回max length, 比如 dict , input: fireman, 有两种可能 以及 返回3 
第三轮： 午饭 
第四轮： sublime coding, spiral matrix

第一面问了Word break变形 输出有效break的可能里最多的break次数 比如词是“abbc”，字典是"a", "b", "bc", "ab", 
有两种可能 一种是a, b, bc, 一种ab, bc，要输出3 

然后转天就来2面了 第二面聊了很多简历上的事 感觉之前实习做的事还挺冷门的但是面试官表示他以前也有这方面的经验所以很感兴趣…问的超细致 
最后时间不多了他说就写个sqrt吧，也是返回int但是跟lc不同的是要返回平方后大于等于输入值的结果 比如输入15的话要返回4，
lc我记得是返回3 用二分写 写的倒是挺快的但是就在check mid >= n / mid时忘记了那个除是向下round的…于是有时就off by 1...
然后改了改最后对了但是感觉有点不好……希望有rp 

sqrt(x, precision)，返回正数x正平方根的浮点数结果，结果范围需要在±precision以内。

1. spiral matrix 只是開始的方向不太一樣
2. first missing positive in unsorted array


1.给定数组，求longest consecutive subarray 例如：输入｛1，4，5，6，8，10，11｝，输出｛4，5，6｝，这个用dp可解 
2.follow up 例子：输入｛1，4，2，5，3，9，10｝，输出｛1，2，3｝ 要求o(nlogn)解法，leetcode上有原题 
https://leetcode.com/problems/longest-increasing-subsequence/discuss/

第二轮： 1.给定长m,宽n，的格子，每次只能向下或向右走，问从最左上角走到最右下角，有多少种方法？dp可解 
2.实现sqrt，不同的是给定精度和target，返回一个精度范围内的值即可 

Given two strings of binary numbers (e.g. ‘101’ and ‘111’), return the sum of those two binary strings as another binary string


Summarize the gaps in a sorted array that should ideally contain consecutive numbers from 1 to K. For example when K=100, the array [3, 4, 5, 7, 75, 76] should give "1-2, 6, 8-74, 77-100" as output. 


You’re given two sets of intervals, one for LinkedIn and one for a Facebook, and you want to find when they are both open. These are hours in 24-hour times, but can be any arbitrary floating point numbers.
D = [(9, 12), (14, 17), (21, 23)]
R = [(8, 10), (11, 22)]
=> [(9, 10), (11, 12), (14, 17), (21, 22)]
You can assume the intervals within a list do not overlap. If they ask, you can assume the lists are sorted. You can assume that the tuple there is really an Interval struct/object with start and end for clarity; no need to write that out.


I want to learn all the store names which are on the Facebook website so people think I'm smart.
I opened up our alphabetical store directory to a random page, looking for stores I didn't know. I put each name I didn't know at increasing indices in a huge array I created in memory. When I reached the end of the directory, I started from the beginning and did the same thing until I reached the page I started at.
Now I have an array of store names that are mostly alphabetical, except they start somewhere in the middle of the alphabet, reach the end, and then start from the beginning of the alphabet. In other words, this is an alphabetically ordered array that has been "rotated." For example:
 names = [
    'MacLaren’s Pub',
    'Monk’s Cafe',
    'Paddy’s Pub',
    'Taco Town',
    'Xylophone Cafe',
    'Abdul’s Orange Chicken Emporium', # <-- rotates here!
    'Bob’s Burgers',
    'Central Perk',
    ‘Da Situation',
    'Krusty Krab',
    'Los Pollos Hermanos',
]


Write a function for finding the index of the "rotation point," which is where I started working from the beginning of the directory. This array is huge (there are lots of stores I don't know) so we want to be efficient here.

Given a grid of size m x n, count the number of paths from top-left cell to bottom-right cell if we can either move down or right from each cell in the grid.

Start |  R |    | 
  D   |    |    | 
      |    |    |  Goal
      
      
      
      
Facebook operates in N neighborhoods within San Francisco. You are given an array where arr[i] represents the number of deliveries made in neighborhood i. You need to return an array where result[i] is the number of deliveries made in all neighborhoods except neighborhood i and you cannot use subtraction.

Example:
13
78
95
203
89

Returns
78+95+203+89
13+95+203+89
13+78+203+89
13+78+95+89
13+78+95+203
      
Input   Output
13        78+95+203+89
78        13+95+203+89



Given any number n, how many ways can we express the number as the sum of 1, 3, and 4?

Example: Given n = 5, the answer is 6
5 = 1 + 1 + 1 + 1 + 1
5 = 1 + 1 + 3
5 = 1 + 3 + 1
5 = 3 + 1 + 1
5 = 1 + 4
5 = 4 + 1

Implement a fixed size in-memory cache. If the cache is full, evict elements based on the time that they were added to the cache, aka evict the most stale (oldest untouched) element when storage is full. 
(Include implementations for GET, SET, and UPDATE)






