   //BFS, time: O(MN), space: O(MN)
   
   public void solve(char[][] board) {
        //start from 'O' that are on the edges
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if ((i == 0 || j == 0 || i == board.length - 1 || j == board[0].length - 1) && board[i][j] == 'O') {
                   Queue<Integer> q = new LinkedList<Integer>();
                    q.offer(i*board[0].length + j);
                    board[i][j] = '$';
                    while (!q.isEmpty()) {
                        Integer key = q.poll();
                        int x = key/board[0].length;
                        int y = key%board[0].length;
                        //the neighbor of (x, y) that are 'O' are marked
                        if (x > 0 && board[x-1][y] == 'O') {
                            q.offer((x-1)*board[0].length + y);
                            board[x-1][y] = '$';
                        }
                        if (x < board.length - 1 && board[x+1][y] == 'O') {
                            q.offer((x+1)*board[0].length + y);
                            board[x+1][y] = '$';
                        }
                        if (y > 0 && board[x][y-1] == 'O') {
                            q.offer(x*board[0].length + y-1);
                            board[x][y-1] = '$';
                        }
                        if (y < board[0].length - 1 && board[x][y+1] == 'O') {
                            q.offer(x*board[0].length + y+1);
                            board[x][y+1] = '$';
                        }
                    }
                }
            }
        }
        //recover the board
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == 'O') board[i][j] = 'X';
                if (board[i][j] == '$') board[i][j] = 'O';
            }
        }
    }
